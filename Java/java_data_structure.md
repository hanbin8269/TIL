# 자바 자료구조


### 2의 보수
컴퓨터에서 음수를 표현할 때 `2의 보수`로 표현한다.

- `보수` - 보충해주는 수
`ex) 10진수에서 6에대한 보수는 4, 5에 대한 보수는 5`

`0000 1010` = 10 첫번째 비트가 부호 비트 (`Most Significant Bit, MSB`)

`1000 1010`는 -10 일까?

하지만 두 수를 더하면 `0000 0000`이 나오지 않는다. 제대로 된 음수를 표현해 보자

`0000 1010`의 1의 보수는 `1111 0101`이다. 이거에 1을 더한 값은 `1111 0110`이다.

`0000 1010`과 `1111 0110`을 더하면 `1 0000 0000` 이 되는데, 맨 앞의 `1`은 8byte를 초과하므로 절삭한다. 그렇게 `0000 0000`이 된다.

여기서 1의 보수에 1을 더해 얻은 `1111 0110`을 **2의 보수**라 하며, 음수를 표현하는 방법이다.

### 변수와 메모리
변수를 선언하는 것은 해당 자료형의 크기 만큼의 메모리를 사용하겠다는 것이다.

메모리의 위치를 변수 이름으로 참조한다.

`ex) integer - 4byte`


### 상수와 리터럴
#### 상수란?
상수 : 변하지 않는 수
#### 리터럴이란?
> **컴퓨터 과학 분야에서 리터럴이란, 소스코드의 고정된 값을 대표하는 용어이다.** - 위키백과

이 말만 보고 "리터럴은 상수인가?" 생각할 수 있는데 아니다.

리터럴은 어떠한 값을 명칭하는 것이 아닌 변수 및 상수에 저장되는 **'값 자체'** 를 일컫는 말이다.

`ex) int a = 10` 에서 10이 리터럴이다.

또한, 모든 리터럴은 상수 풀(constant pool)에 저장되어 있다.

### 배열
- **동일한** 자료형의 **순차적** 자료구조
```java
int[] arr = new int[10];
int arr[] = new int[10]; 
// 둘이 같은거다.
```

#### 특징
- 배열은 항상 `0 index`부터 시작한다.

#### 선언 방법
```java
int[] arr = new int[10];

int arr[] = new int[10]; 
// 둘이 같은거다.

int[] arr = new int[] {1,2,3};

int[] arr;
arr = new int[] {1,2,3};
// 선언과 동시에 초기화
```

#### 객체 배열
객체 배열은 참조하는 객체의 주소값을 배열에 넣는다.
```java
Book[] library = new Book[5];
Book[] copyLibrary = new Book[5];

library[0] = new Book("태백산맥1", "조정래");
library[1] = new Book("태백산맥2", "조정래");
library[2] = new Book("태백산맥3", "조정래");
library[3] = new Book("태백산맥4", "조정래");
library[4] = new Book("태백산맥5", "조정래");

System.arraycopy(library, 0, copyLibrary, 0, 5);
 
library[0].setTitle("나목");
library[0].setAuthor("박완서");

for( Book book : library) {
	book.showBookInfo();
}

System.out.println("===============");

for(Book book : copyLibrary) {
	book.showBookInfo();
}
```
그렇기 떄문에 위와 같이 복사를 해버리면 `library`의 멤버변수의 값을 바꿔도 `copyLibrary`와 동일한 값을 가지게 된다. 이를 **얕은복사**라고 한다.

이를 방지하기 위해서는 따로 인스턴스를 생성한 다음에 값을 변경해줘야 한다.
